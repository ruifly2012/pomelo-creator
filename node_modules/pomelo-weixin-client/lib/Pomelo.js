'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events');
var Message = require('./Message');
var Protocol = require('./Protocal');
var Package = require('./Package');

var DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;

var JS_WS_CLIENT_TYPE = 'js-websocket';
var JS_WS_CLIENT_VERSION = '0.0.1';

var RES_OK = 200;
var RES_FAIL = 500;
var RES_OLD_CLIENT = 501;

function blobToBuffer(blob, cb) {
    var fileReader = new FileReader();
    fileReader.onload = function (event) {
        var buffer = event.target.result;
        cb(buffer);
    };
    fileReader.readAsArrayBuffer(blob);
}

function defaultDecode(data) {
    var msg = Message.decode(data);
    msg.body = JSON.parse(Protocol.strdecode(msg.body));
    return msg;
}
function defaultEncode(reqId, route, msg) {
    var type = reqId ? Message.TYPE_REQUEST : Message.TYPE_NOTIFY;
    msg = Protocol.strencode(JSON.stringify(msg));
    var compressRoute = 0;
    return Message.encode(reqId, type, compressRoute, route, msg);
}
function defaultUrlGenerator(host, port) {
    var url = 'ws://' + host;
    if (port) {
        url += ':' + port;
    }
    return url;
}

module.exports = function (_EventEmitter) {
    _inherits(Pomelo, _EventEmitter);

    function Pomelo(args) {
        _classCallCheck(this, Pomelo);

        var _this = _possibleConstructorReturn(this, (Pomelo.__proto__ || Object.getPrototypeOf(Pomelo)).call(this, args));

        var wsCreator = args.wsCreator,
            wsCreatorWeb = args.wsCreatorWeb,
            _args$urlGenerator = args.urlGenerator,
            urlGenerator = _args$urlGenerator === undefined ? defaultUrlGenerator : _args$urlGenerator;

        _this.wsCreator = wsCreator;
        _this.wsCreatorWeb = wsCreatorWeb;
        _this.urlGenerator = urlGenerator;

        _this.reconnect = false;
        _this.reconncetTimer = null;
        _this.reconnectAttempts = 0;
        _this.reconnectionDelay = 5000;

        _this.handshakeBuffer = {
            'sys': {
                type: JS_WS_CLIENT_TYPE,
                version: JS_WS_CLIENT_VERSION,
                rsa: {}
            },
            'user': {}
        };

        _this.heartbeatInterval = 0;
        _this.heartbeatTimeout = 0;
        _this.nextHeartbeatTimeout = 0;
        _this.gapThreshold = 100; // heartbeat gap threashold
        _this.heartbeatId = null;
        _this.heartbeatTimeoutId = null;
        _this.handshakeCallback = null;

        _this.callbacks = {};
        _this.handlers = {};
        _this.handlers[Package.TYPE_HANDSHAKE] = _this.handshake.bind(_this);
        _this.handlers[Package.TYPE_HEARTBEAT] = _this.heartbeat.bind(_this);
        _this.handlers[Package.TYPE_DATA] = _this.onData.bind(_this);
        _this.handlers[Package.TYPE_KICK] = _this.onKick.bind(_this);

        _this.reqId = 0;
        return _this;
    }

    _createClass(Pomelo, [{
        key: 'handshake',
        value: function handshake(data) {
            data = JSON.parse(Protocol.strdecode(data));
            if (data.code === RES_OLD_CLIENT) {
                this.emit('error', 'client version not fullfill');
                return;
            }

            if (data.code !== RES_OK) {
                this.emit('error', 'handshake fail');
                return;
            }
            this.handshakeInit(data);

            var obj = Package.encode(Package.TYPE_HANDSHAKE_ACK);
            this.send(obj);
            this.initCallback && this.initCallback(this.socket);
        }
    }, {
        key: 'handshakeInit',
        value: function handshakeInit(data) {
            if (data.sys && data.sys.heartbeat) {
                this.heartbeatInterval = data.sys.heartbeat * 1000; // heartbeat interval
                this.heartbeatTimeout = this.heartbeatInterval * 2; // max heartbeat timeout
            } else {
                this.heartbeatInterval = 0;
                this.heartbeatTimeout = 0;
            }

            typeof this.handshakeCallback === 'function' && this.handshakeCallback(data.user);
        }
    }, {
        key: 'heartbeat',
        value: function heartbeat(data) {
            var _this2 = this;

            if (!this.heartbeatInterval) {
                return;
            }

            var obj = Package.encode(Package.TYPE_HEARTBEAT);
            if (this.heartbeatTimeoutId) {
                clearTimeout(this.heartbeatTimeoutId);
                this.heartbeatTimeoutId = null;
            }

            if (this.heartbeatId) {
                // already in a heartbeat interval
                return;
            }
            this.heartbeatId = setTimeout(function () {
                _this2.heartbeatId = null;
                _this2.send(obj);

                _this2.nextHeartbeatTimeout = Date.now() + _this2.heartbeatTimeout;
                _this2.heartbeatTimeoutId = setTimeout(_this2.heartbeatTimeoutCb, _this2.heartbeatTimeout);
            }, this.heartbeatInterval);
        }
    }, {
        key: 'heartbeatTimeoutCb',
        value: function heartbeatTimeoutCb() {
            var gap = this.nextHeartbeatTimeout - Date.now();
            if (gap > this.gapThreshold) {
                this.heartbeatTimeoutId = setTimeout(this.heartbeatTimeoutCb, gap);
            } else {
                console.error('server heartbeat timeout');
                this.emit('heartbeat timeout');
                this.disconnect();
            }
        }
    }, {
        key: 'reset',
        value: function reset() {
            this.reconnect = false;
            this.reconnectionDelay = 1000 * 5;
            this.reconnectAttempts = 0;
            clearTimeout(this.reconncetTimer);
        }
    }, {
        key: 'init',
        value: function init(params, cb) {
            this.initCallback = cb;

            this.params = params;
            var host = params.host,
                port = params.port,
                user = params.user,
                handshakeCallback = params.handshakeCallback,
                _params$encode = params.encode,
                encode = _params$encode === undefined ? defaultEncode : _params$encode,
                _params$decode = params.decode,
                decode = _params$decode === undefined ? defaultDecode : _params$decode,
                debugMode = params.debugMode,
                browserWS = params.browserWS;


            this.encode = encode;
            this.decode = decode;

            if (debugMode) {
                this.url = defaultUrlGenerator(host, port);
            } else {
                this.url = this.urlGenerator(host, port);
            }

            if (browserWS) {
                this.wsCreator = this.wsCreatorWeb;
                this.browserWS = browserWS;
            }

            this.handshakeBuffer.user = user;
            this.handshakeCallback = handshakeCallback;
            this.connect();
        }
    }, {
        key: 'connect',
        value: function connect() {
            var _this3 = this;

            var params = this.params;
            var maxReconnectAttempts = params.maxReconnectAttempts || DEFAULT_MAX_RECONNECT_ATTEMPTS;
            var reconnectUrl = this.url;

            var onOpen = function onOpen(event) {
                if (!!_this3.reconnect) {
                    _this3.emit('reconnect');
                }
                _this3.reset();
                var obj = Package.encode(Package.TYPE_HANDSHAKE, Protocol.strencode(JSON.stringify(_this3.handshakeBuffer)));
                _this3.send(obj);
            };
            var onMessage = function onMessage(event) {
                if (_this3.browserWS) {
                    blobToBuffer(event.data, function (buffer) {
                        _this3.processPackage(Package.decode(buffer));
                        // new package arrived, update the heartbeat timeout
                        if (_this3.heartbeatTimeout) {
                            _this3.nextHeartbeatTimeout = Date.now() + _this3.heartbeatTimeout;
                        }
                    });
                } else {
                    _this3.processPackage(Package.decode(event.data));
                    // new package arrived, update the heartbeat timeout
                    if (_this3.heartbeatTimeout) {
                        _this3.nextHeartbeatTimeout = Date.now() + _this3.heartbeatTimeout;
                    }
                }
            };
            var onError = function onError(event) {
                _this3.emit('io-error', event);
                console.error('socket error: ', event);
            };
            var onClose = function onClose(event) {
                _this3.emit('close', event);
                _this3.emit('disconnect', event);
                if (!!params.reconnect && _this3.reconnectAttempts < maxReconnectAttempts) {
                    _this3.reconnect = true;
                    _this3.reconnectAttempts++;
                    _this3.reconncetTimer = setTimeout(function () {
                        return _this3.connect();
                    }, _this3.reconnectionDelay);
                    _this3.reconnectionDelay *= 2;
                }
            };

            // socket = wx.connectSocket({ url: reconnectUrl });
            this.socket = this.wsCreator({
                url: reconnectUrl,
                onError: onError,
                onOpen: onOpen,
                onMessage: onMessage,
                onClose: onClose
            });
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            if (this.socket) {
                this.socket.close();
                this.socket = false;
            }

            if (this.heartbeatId) {
                clearTimeout(this.heartbeatId);
                this.heartbeatId = null;
            }
            if (this.heartbeatTimeoutId) {
                clearTimeout(this.heartbeatTimeoutId);
                this.heartbeatTimeoutId = null;
            }
        }
    }, {
        key: 'request',
        value: function request(route, msg, cb) {
            if (arguments.length === 2 && typeof msg === 'function') {
                cb = msg;
                msg = {};
            } else {
                msg = msg || {};
            }
            route = route || msg.route;
            if (!route) {
                return;
            }

            this.reqId++;
            this.sendMessage(this.reqId, route, msg);

            this.callbacks[this.reqId] = cb;
        }
    }, {
        key: 'notify',
        value: function notify(route, msg) {
            msg = msg || {};
            this.sendMessage(0, route, msg);
        }
    }, {
        key: 'sendMessage',
        value: function sendMessage(reqId, route, msg) {
            msg = this.encode(reqId, route, msg);

            var packet = Package.encode(Package.TYPE_DATA, msg);
            this.send(packet);
        }
    }, {
        key: 'send',
        value: function send(packet) {
            if (this.browserWS) {
                this.socket.send(packet.buffer);
            } else {
                this.socket.send({ data: packet.buffer });
            }
        }
    }, {
        key: 'onData',
        value: function onData(msg) {
            msg = this.decode(msg);
            this.processMessage(msg);
        }
    }, {
        key: 'onKick',
        value: function onKick(data) {
            data = JSON.parse(Protocol.strdecode(data));
            this.emit('onKick', data);
        }
    }, {
        key: 'processMessage',
        value: function processMessage(msg) {
            if (!msg.id) {
                this.emit(msg.route, msg.body);
                return;
            }

            //if have a id then find the callback function with the request
            var cb = this.callbacks[msg.id];

            delete this.callbacks[msg.id];
            typeof cb === 'function' && cb(msg.body);
        }
    }, {
        key: 'processPackage',
        value: function processPackage(msgs) {
            if (Array.isArray(msgs)) {
                for (var i = 0; i < msgs.length; i++) {
                    var msg = msgs[i];
                    this.handlers[msg.type](msg.body);
                }
            } else {
                this.handlers[msgs.type](msgs.body);
            }
        }
    }, {
        key: 'newInstance',
        value: function newInstance() {
            return new Pomelo({
                wsCreator: this.wsCreator,
                urlGenerator: this.urlGenerator
            });
        }
    }]);

    return Pomelo;
}(EventEmitter);