'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./util'),
    copyArray = _require.copyArray;

var PKG_HEAD_BYTES = 4;
var TYPE_HANDSHAKE = 1;
var TYPE_HANDSHAKE_ACK = 2;
var TYPE_HEARTBEAT = 3;
var TYPE_DATA = 4;
var TYPE_KICK = 5;

module.exports = function () {
    function Package() {
        _classCallCheck(this, Package);
    }

    _createClass(Package, null, [{
        key: 'encode',

        /**
         * Package protocol encode.
         *
         * Pomelo package format:
         * +------+-------------+------------------+
         * | type | body length |       body       |
         * +------+-------------+------------------+
         *
         * Head: 4bytes
         *   0: package type,
         *      1 - handshake,
         *      2 - handshake ack,
         *      3 - heartbeat,
         *      4 - data
         *      5 - kick
         *   1 - 3: big-endian body length
         * Body: body length bytes
         *
         * @param  {Number}    type   package type
         * @param  {Uint8Array} body   body content in bytes
         * @return {Uint8Array}        new byte array that contains encode result
         */
        value: function encode(type, body) {
            var length = body ? body.length : 0;
            var buffer = new Uint8Array(PKG_HEAD_BYTES + length);
            var index = 0;
            buffer[index++] = type & 0xff;
            buffer[index++] = length >> 16 & 0xff;
            buffer[index++] = length >> 8 & 0xff;
            buffer[index++] = length & 0xff;
            if (body) {
                copyArray(buffer, index, body, 0, length);
            }
            // return String.fromCharCode.apply(null,buffer);
            return buffer;
        }

        /**
         * Package protocol decode.
         * See encode for package format.
         *
         * @param  {Uint8Array} buffer byte array containing package content
         * @return {Object}           {type: package type, buffer: body byte array}
         */

    }, {
        key: 'decode',
        value: function decode(buffer) {
            // buffer = toUTF8Array(str)
            var offset = 0;
            var bytes = new Uint8Array(buffer);
            var length = 0;
            var rs = [];
            while (offset < bytes.length) {
                var type = bytes[offset++];
                length = (bytes[offset++] << 16 | bytes[offset++] << 8 | bytes[offset++]) >>> 0;
                var body = length ? new Uint8Array(length) : null;
                copyArray(body, 0, bytes, offset, length);
                offset += length;
                rs.push({ 'type': type, 'body': body });
            }
            return rs.length === 1 ? rs[0] : rs;
        }
    }, {
        key: 'TYPE_HANDSHAKE',
        get: function get() {
            return TYPE_HANDSHAKE;
        }
    }, {
        key: 'TYPE_HANDSHAKE_ACK',
        get: function get() {
            return TYPE_HANDSHAKE_ACK;
        }
    }, {
        key: 'TYPE_HEARTBEAT',
        get: function get() {
            return TYPE_HEARTBEAT;
        }
    }, {
        key: 'TYPE_DATA',
        get: function get() {
            return TYPE_DATA;
        }
    }, {
        key: 'TYPE_KICK',
        get: function get() {
            return TYPE_KICK;
        }
    }]);

    return Package;
}();