'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Protocol = require('./Protocal');

var _require = require('./util'),
    copyArray = _require.copyArray;

var TYPE_REQUEST = 0;
var TYPE_NOTIFY = 1;
var TYPE_RESPONSE = 2;
var TYPE_PUSH = 3;

var MSG_FLAG_BYTES = 1;
var MSG_ROUTE_CODE_BYTES = 2;
var MSG_ID_MAX_BYTES = 5;
var MSG_ROUTE_LEN_BYTES = 1;

var MSG_ROUTE_CODE_MAX = 0xffff;

var MSG_COMPRESS_ROUTE_MASK = 0x1;
var MSG_TYPE_MASK = 0x7;

module.exports = function () {
    function Message() {
        _classCallCheck(this, Message);
    }

    _createClass(Message, null, [{
        key: 'encode',

        /**
         * Message protocol encode.
         *
         * @param  {Number} id            message id
         * @param  {Number} type          message type
         * @param  {Number} compressRoute whether compress route
         * @param  {Number|String} route  route code or route string
         * @param  {Buffer} msg           message body bytes
         * @return {Buffer}               encode result
         */
        value: function encode(id, type, compressRoute, route, msg) {
            // caculate message max length
            var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;
            var msgLen = MSG_FLAG_BYTES + idBytes;

            if (msgHasRoute(type)) {
                if (compressRoute) {
                    if (typeof route !== 'number') {
                        throw new Error('error flag for number route!');
                    }
                    msgLen += MSG_ROUTE_CODE_BYTES;
                } else {
                    msgLen += MSG_ROUTE_LEN_BYTES;
                    if (route) {
                        route = Protocol.strencode(route);
                        if (route.length > 255) {
                            throw new Error('route maxlength is overflow');
                        }
                        msgLen += route.length;
                    }
                }
            }
            if (msg) {
                msgLen += msg.length;
            }

            var buffer = new Uint8Array(msgLen);
            var offset = 0;

            // add flag
            offset = encodeMsgFlag(type, compressRoute, buffer, offset);

            // add message id
            if (msgHasId(type)) {
                offset = encodeMsgId(id, buffer, offset);
            }

            // add route
            if (msgHasRoute(type)) {
                offset = encodeMsgRoute(compressRoute, route, buffer, offset);
            }

            // add body
            if (msg) {
                offset = encodeMsgBody(msg, buffer, offset);
            }

            return buffer;
        }

        /**
         * Message protocol decode.
         *
         * @param  {Buffer|Uint8Array} buffer message bytes
         * @return {Object}            message object
         */

    }, {
        key: 'decode',
        value: function decode(buffer) {
            var bytes = new Uint8Array(buffer);
            var bytesLen = bytes.length || bytes.byteLength;
            var offset = 0;
            var id = 0;
            var route = null;

            // parse flag
            var flag = bytes[offset++];
            var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;
            var type = flag >> 1 & MSG_TYPE_MASK;

            // parse id
            if (msgHasId(type)) {
                var m = parseInt(bytes[offset]);
                var i = 0;
                do {
                    var m = parseInt(bytes[offset]);
                    id = id + (m & 0x7f) * Math.pow(2, 7 * i);
                    offset++;
                    i++;
                } while (m >= 128);
            }

            // parse route
            if (msgHasRoute(type)) {
                if (compressRoute) {
                    route = bytes[offset++] << 8 | bytes[offset++];
                } else {
                    var routeLen = bytes[offset++];
                    if (routeLen) {
                        route = new Uint8Array(routeLen);
                        copyArray(route, 0, bytes, offset, routeLen);
                        route = Protocol.strdecode(route);
                    } else {
                        route = '';
                    }
                    offset += routeLen;
                }
            }

            // parse body
            var bodyLen = bytesLen - offset;
            var body = new Uint8Array(bodyLen);

            copyArray(body, 0, bytes, offset, bodyLen);

            return {
                'id': id, 'type': type, 'compressRoute': compressRoute,
                'route': route, 'body': body
            };
        }
    }, {
        key: 'TYPE_REQUEST',
        get: function get() {
            return TYPE_REQUEST;
        }
    }, {
        key: 'TYPE_NOTIFY',
        get: function get() {
            return TYPE_NOTIFY;
        }
    }, {
        key: 'TYPE_RESPONSE',
        get: function get() {
            return TYPE_RESPONSE;
        }
    }, {
        key: 'TYPE_PUSH',
        get: function get() {
            return TYPE_PUSH;
        }
    }]);

    return Message;
}();

var msgHasId = function msgHasId(type) {
    return type === TYPE_REQUEST || type === TYPE_RESPONSE;
};

var msgHasRoute = function msgHasRoute(type) {
    return type === TYPE_REQUEST || type === TYPE_NOTIFY || type === TYPE_PUSH;
};

var caculateMsgIdBytes = function caculateMsgIdBytes(id) {
    var len = 0;
    do {
        len += 1;
        id >>= 7;
    } while (id > 0);
    return len;
};

var encodeMsgFlag = function encodeMsgFlag(type, compressRoute, buffer, offset) {
    if (type !== TYPE_REQUEST && type !== TYPE_NOTIFY && type !== TYPE_RESPONSE && type !== TYPE_PUSH) {
        throw new Error('unkonw message type: ' + type);
    }

    buffer[offset] = type << 1 | (compressRoute ? 1 : 0);

    return offset + MSG_FLAG_BYTES;
};

var encodeMsgId = function encodeMsgId(id, buffer, offset) {
    do {
        var tmp = id % 128;
        var next = Math.floor(id / 128);

        if (next !== 0) {
            tmp = tmp + 128;
        }
        buffer[offset++] = tmp;

        id = next;
    } while (id !== 0);

    return offset;
};

var encodeMsgRoute = function encodeMsgRoute(compressRoute, route, buffer, offset) {
    if (compressRoute) {
        if (route > MSG_ROUTE_CODE_MAX) {
            throw new Error('route number is overflow');
        }

        buffer[offset++] = route >> 8 & 0xff;
        buffer[offset++] = route & 0xff;
    } else {
        if (route) {
            buffer[offset++] = route.length & 0xff;
            copyArray(buffer, offset, route, 0, route.length);
            offset += route.length;
        } else {
            buffer[offset++] = 0;
        }
    }

    return offset;
};

var encodeMsgBody = function encodeMsgBody(msg, buffer, offset) {
    copyArray(buffer, offset, msg, 0, msg.length);
    return offset + msg.length;
};